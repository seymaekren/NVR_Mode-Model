///////////////////////////////////////////////////////////////////////////////////////////////
//	BBMinimizer.java
//
//	Version:           0.3
//
//
//	  authors:
// 	  initials    name                 organization                email
//	 ---------   -----------------    ------------------------    ----------------------------
//	  ISG		 Ivelin Georgiev	  Duke University			  ivelin.georgiev@duke.edu
//
///////////////////////////////////////////////////////////////////////////////////////////////

/**
* Written by Ivelin Georgiev (2004-2006)
* 
*/

/*
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.
	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
	Lesser General Public License for more details.
	
	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
	USA
	
	Contact Info:
		Bruce Donald
		Duke University
		Department of Computer Science
		Levine Science Research Center (LSRC)
		Durham
		NC 27708-0129 
		USA
		brd@cs.duke.edu
	
	If you use or publish any results derived from the use of this
	program please cite:
	Georgiev I, Lilien R, Donald B. "Improved Pruning Algorithms and
	Divide-and-Conquer Strategies for Dead-End Elimination, with Application 
	to Protein Design" Bioinformatics, 22(14): e174-e183, 2006.
	
	Copyright (C) 2006 Ivelin Georgiev, Ryan H. Lilien, and Bruce R. Donald
		
	<signature of Bruce Donald>, 23 Aug, 2006
	Bruce Donald, Professor of Computer Science
*/

import java.io.Serializable;

/* 
 * Handles two types of energy minimization:
 * 		(1) the minimization required for computing the pairwise energy matrices;
 * 		(2) the minimization of a full conformation: the side-chain dihedrals are kept rigid,
 * 				while the backbone dihedrals are allowed to move within given limits
 * 
 */
public class BBMinimizer implements Serializable {
	
	final int MAX_NUM_ATOMS_RES = 100; //the max number of atoms for e given residue
	
	Molecule m = null;
	Amber96ext a96ff = null;
	
	int numFlexRes = -1; //the number of residues with flexible side-chains (only in the system strand, and not the ligand)	
	int flexResAtomList[][] = new int[0][0]; 
		// each row is a residue and contains
		//  the moleucleatomnumbers located more
		//  distal than the 3rd atom of any dihedral
	int flexResListSize[] = new int[0]; // the number of valid elements in each row of flexResAtomList
	
	int residueMap[] = null; //the mapping between AS and molecule-relative residue numbering
	
	int ligResNum = -1; // the residue index of the ligand in the flexResAtomList, flexResListSize
	int ligStrNum = -1; // the ligand strand number (if ligStrNum == -1 then there is no ligand)
	
	int sysStrNum = -1; //the system strand number

	boolean doDihedEnergy = false; // If true then dihedral energies (for BB only) are computed and used in minimization
	boolean hVDW = false; // determines if hydrogens should be used in steric checks
	
	final int numStepsFiPsi = 35; //the number of phi/psi minimization steps to be performed	
	final float sysMaxDihedRot = 3.0f; //the maximum rotation from the initial phi/sp values
	private float sysFiPsiStep = 0.2f; //initial step size for phi/psi changes; used for full conformation energy minimization; depends on the value of sysMaxDihedRot and numStepsFiPsi
	
	float sysMaxTrans = 1.5f;//2.0f; //the maximum displacement (in angstrom) from the initial CA
	double sysStartCA[][] = null; // the position of the initial CA for each flexible residue
	
	float sysCurFiPsiDisp[][] = null;
	
	double ligStartCOM[] = new double[3]; // the position of the ligand's initial COM
	double ligCurCOM[] = new double[3]; // the ligand's current COM
	float ligRotSize = 0.4f; //initial rotation angle size (in degrees)
	float ligTransSize = 0.3f; //initial translation size (in angstrom)
	
	double eps = 0.1; //the epsilon value used to scale the gradient for steepest descent
	
	
	//constructor
	BBMinimizer(){
	}
	
	//Initialize for the system strand only
	public void initialize(Molecule mol, Amber96ext theA96ff, boolean doDihedE, int resMap[], int sysStrand, boolean hydVDW) {
		
		m = mol;
		a96ff = theA96ff;
		sysStrNum = sysStrand;
		residueMap = resMap;
		
		doDihedEnergy = doDihedE;
		hVDW = hydVDW;

		// Count number of flexible residues
		numFlexRes = 0;
		for(int i=0;i<m.strand[sysStrNum].numberOfResidues;i++){
			if(m.strand[sysStrNum].residue[i].flexible)
				numFlexRes++;
		}
		
		// 2 is added to numFlexRes so that there is room for the ligand at the
		//  end if there is a ligand present, if there is no ligand then it
		//  doesn't really matter as we won't look at that row
		// The first ligand term includes nonbonded terms for computing energies
		// The second ligand term includes nonbonded terms for computing the gradient
		//  and thus includes terms for all atoms
		flexResAtomList = new int[numFlexRes+2][MAX_NUM_ATOMS_RES];
		flexResListSize = new int[numFlexRes+2];
		
		int curNumFlex = 0;
		Residue localRes = null;
		for(int i=0;i<m.strand[sysStrNum].numberOfResidues;i++){
			localRes = m.strand[sysStrNum].residue[i];
			if(localRes.flexible){
				flexResListSize[curNumFlex] = localRes.numberOfAtoms;
				for(int k=0;k<flexResListSize[curNumFlex];k++){
					flexResAtomList[curNumFlex][k] = localRes.atom[k].moleculeAtomNumber;
				}
				curNumFlex++;
			}
		}
		
		sysStartCA = new double[m.numberOfResidues][3];
		for (int i=0; i<m.numberOfResidues; i++)
			sysStartCA[i] = getCAcoord(i);
		
		sysCurFiPsiDisp = new float[m.numberOfResidues][2];
		for (int i=0; i<sysCurFiPsiDisp.length; i++){
			sysCurFiPsiDisp[i][0] = 0.0f;
			sysCurFiPsiDisp[i][1] = 0.0f;
		}
	}
	
	//Initialize for a system and a ligand
	public void initialize(Molecule mol, Amber96ext theA96ff, boolean doDihedE, int resMap[], int sysStrand,
			int ligStrand, boolean hydVDW){
	
		// First call the other initialize interface to grab the system information
		initialize(mol,theA96ff,doDihedE,resMap,sysStrand,hydVDW);
		
		ligStrNum = ligStrand;
		ligResNum = numFlexRes;  // numFlexRes was set in the other initialize call
		
		Residue localRes = m.strand[ligStrNum].residue[0];
		
		flexResListSize[ligResNum + 1] = localRes.numberOfAtoms;
		for(int k=0;k<flexResListSize[ligResNum + 1];k++){
			flexResAtomList[ligResNum + 1][k] = localRes.atom[k].moleculeAtomNumber;
		}

		if(m.strand[ligStrNum].residue[0].flexible){
			flexResListSize[ligResNum] = localRes.numberOfAtoms;
			for(int k=0;k<flexResListSize[ligResNum];k++){
				flexResAtomList[ligResNum][k] = localRes.atom[k].moleculeAtomNumber;
			}
		}
	}
	
	//Setup the Amber partial arrays
	public void setupPartialAmber(){
		// numFlexRes, flexResAtomList, and flexResListSize include the ligand if one exists
		if(ligStrNum != -1)
			a96ff.setupPartialArrays(numFlexRes+2,MAX_NUM_ATOMS_RES,flexResAtomList,
				flexResListSize);
		else
			a96ff.setupPartialArrays(numFlexRes,MAX_NUM_ATOMS_RES,flexResAtomList,
				flexResListSize);
	}
	
	//Minimizes the energy of a fully-assigned AA sequence with fully-assigned rotamer identities,
	//		starting with a given template
	public void minimizeFull(boolean pemComp){
			
		float rotStep = ligRotSize;
		float transStep = ligTransSize;
		
		float deltaRotStep = rotStep/numStepsFiPsi;
		float deltaTransStep = transStep/numStepsFiPsi;
		
		int ligNum = -1;		
		if(ligStrNum != -1){
			// get the staring COM
			ligStartCOM = m.getStrandCOM(ligStrNum);
			ligCurCOM[0] = ligStartCOM[0];
			ligCurCOM[1] = ligStartCOM[1];
			ligCurCOM[2] = ligStartCOM[2];
			
			ligNum = m.strand[ligStrNum].residue[0].moleculeResidueNumber;
		}		
		double ligTorque[] = new double[3];
		double ligTrans[] = new double[3];
		
		Backbone bb = new Backbone();
		
		for (int i=0; i<numStepsFiPsi; i++) {
		
			for (int j=0; j<residueMap.length; j++){ //apply the current phi/psi step for each of the flexible residues
				int asResNum = m.residue[residueMap[j]].strandResidueNumber;
				for (int a=0; a<2; a++) // (a==0) applies a phi change; (a==1) applies a psi change
					compFiPsi(asResNum,sysStrNum,a,sysFiPsiStep,bb,pemComp);
			}
			
			if (ligStrNum!=-1) //there is a ligand, so translate/rotate the ligand
				doLigTransRot(ligNum, ligTorque, ligTrans, rotStep, transStep, sysMaxTrans);
			
			//reduce the step size for the next minimization step
			rotStep -= deltaRotStep;
			transStep -= deltaTransStep;
		}
	}
	
	//Checks the energy if a phi (angleType==0) or psi (angleType==1) change of +fiPsiStep
	//		is applied to residue resNum (strand-relative numbering, only residues in strand strandNum are considered);
	//If at least one residue is moved further than the maximum allowed limit for its CA, then the
	//		step in the corresponding direction is not considered
	private void compFiPsi(int asResNum, int strandNum, int angleType, float fiPsiStep, Backbone bb, boolean pemComp){
		
		double initialEnergy[], secondEnergy[];
		float storedCoord[][] = new float[m.numberOfResidues][];
		
		//Store the actualCoordinates[] before any changes
		for (int i=0; i<m.strand[strandNum].numberOfResidues; i++)
			storedCoord[i] = storeCoord(m.strand[strandNum].residue[i].moleculeResidueNumber);		
		
		//Check at initial position
		initialEnergy = a96ff.calculateTotalEnergy(m.actualCoordinates,-1);
		
		//Check at +fiPsiStep rotation
		bb.applyFiPsi(m,sysStrNum,asResNum,fiPsiStep,angleType);	
		secondEnergy = a96ff.calculateTotalEnergy(m.actualCoordinates,-1);
		for (int i=0; i<m.strand[strandNum].numberOfResidues; i++)
			restoreCoord(i,storedCoord[m.strand[strandNum].residue[i].moleculeResidueNumber]);
		
		int molResNum = m.strand[strandNum].residue[asResNum].moleculeResidueNumber;
		double step = -eps*(secondEnergy[0] - initialEnergy[0])/fiPsiStep;		
		if (step + sysCurFiPsiDisp[molResNum][angleType] > sysMaxDihedRot)
			step = sysMaxDihedRot - sysCurFiPsiDisp[molResNum][angleType];
		if (step + sysCurFiPsiDisp[molResNum][angleType] < -sysMaxDihedRot)
			step = -sysMaxDihedRot - sysCurFiPsiDisp[molResNum][angleType];
				
		if (Math.abs(step)>0.001){
			bb.applyFiPsi(m,sysStrNum,asResNum,step,angleType);		
			if ( (!checkCAallRes(strandNum)) || ( pemComp && (!isAllowedSteric()) ) ) { //at least one residue moved too far away, so make this step impossible
				for (int i=0; i<m.strand[strandNum].numberOfResidues; i++)
					restoreCoord(i,storedCoord[m.strand[strandNum].residue[i].moleculeResidueNumber]);
			}
			else {
				sysCurFiPsiDisp[molResNum][angleType] += step;
			}
		}
	}
	
	public double getMagnitude(double a[]){
		double sum = 0.0;
		for(int i=0;i<a.length;i++)
			sum += (a[i]*a[i]);
		return(Math.sqrt(sum));
	}
	
	public float getMaxDistCA(){
		return sysMaxTrans;
	}
	
	public float getMaxDihedRot(){
		return sysMaxDihedRot;
	}
	
	//Returns the CA coordinates for residue resNum (molecule-relative numbering)
	public double [] getCAcoord(int resNum){
		
		double coord[] = new double[3];
		
		Residue r = m.residue[resNum];
		for (int i=0; i<r.numberOfAtoms; i++){
			if (r.atom[i].name.equalsIgnoreCase("CA")){
				int curAtom = r.atom[i].moleculeAtomNumber;
				coord[0] = m.actualCoordinates[curAtom*3];
				coord[1] = m.actualCoordinates[curAtom*3+1];
				coord[2] = m.actualCoordinates[curAtom*3+2];
			}
		}
		return coord;
	}
	
	//Returns the distance between the two points given by coordinates coord1[] and coord2[]
	private double getDist(double coord1[], double coord2[]){
		
		double rijx, rijy, rijz, rij, rij2;
		
		rijx = coord1[0] - coord2[0];
		rijy = coord1[1] - coord2[1];
		rijz = coord1[2] - coord2[2];
		rij2 = rijx * rijx + rijy * rijy + rijz * rijz;
		rij = Math.sqrt(rij2);
		
		return rij;
	}
	
	//Returns the current actualCoordinates for residue resNum (molecule-relative numbering)
	private float [] storeCoord(int resNum){
		
		float storedCoord[] = new float[m.residue[resNum].numberOfAtoms * 3];
		for (int i=0; i<m.residue[resNum].numberOfAtoms; i++){
			
			int curAtom = m.residue[resNum].atom[i].moleculeAtomNumber;
			storedCoord[i*3] = m.actualCoordinates[curAtom*3];
			storedCoord[i*3+1] = m.actualCoordinates[curAtom*3+1];
			storedCoord[i*3+2] = m.actualCoordinates[curAtom*3+2];
		}
		return storedCoord;
	}
	
	//Sets the actualCoordinates for residue resNum (molecule-relative numbering) to the ones in storedCoord[]
	private void restoreCoord(int resNum, float storedCoord[]){
		
		for (int i=0; i<m.residue[resNum].numberOfAtoms; i++){
			
			int curAtom = m.residue[resNum].atom[i].moleculeAtomNumber;
			m.actualCoordinates[curAtom*3] = storedCoord[i*3];
			m.actualCoordinates[curAtom*3+1] = storedCoord[i*3+1];
			m.actualCoordinates[curAtom*3+2] = storedCoord[i*3+2];
		}
	}
	
	//Checks the distance between the current CA position and the initial CA position for all residues;
	//		If at least one residue has moved too far, return false; otherwise, return true
	public boolean checkCAallRes(int strandNum){
		
		for (int i=0; i<m.strand[strandNum].numberOfResidues; i++){
			int resNum = m.strand[strandNum].residue[i].moleculeResidueNumber;
			double tmpCA[] = getCAcoord(resNum);
			double dist = getDist(tmpCA,sysStartCA[resNum]);
			if (dist>sysMaxTrans)
				return false;
		}
		return true;
	}
	
	//Sets up and performs ligand translation/rotation
	private void doLigTransRot(int resNum, double ligTorque[], double ligTrans[], float lligRotStep, float lligTransStep, float lligMaxTrans){
		
		float bckpLigCoords[] = storeCoord(resNum); //backup actual ligand coordinates
		double initE[] = a96ff.calculateTotalEnergy(m.actualCoordinates, -1); //compute energy before translation/rotation
	
		a96ff.calculateGradient(-1); //calculate the gradient (perhaps eventually just calculate part of the gradient)
		//a96ff.calculateEVGradientPartWithArrays(ligResNumPP);
		computeLigTorqueTrans(ligTorque, ligTrans);
		applyLigTorqueTrans(ligTorque, lligRotStep, ligTrans, lligTransStep, lligMaxTrans);
		
		double minE[] = a96ff.calculateTotalEnergy(m.actualCoordinates, -1); //compute energy after translation/rotation
		if (initE[0]<minE[0]) { //restore initial ligand actual coordinates if trans/rot increses energy
			restoreCoord(resNum,bckpLigCoords);
		}
	}

	// Computes the torque around the ligand
	public void computeLigTorqueTrans(double ligTorque[], double ligTrans[]){
	
		Strand thisStrand = m.strand[ligStrNum];
		double centOfMass[] = m.getStrandCOM(ligStrNum);
		int atBase = -1;
		double R[] = new double[3];
		double F[] = new double[3];
		double temp[];
		ligTorque[0] = 0.0;
		ligTorque[1] = 0.0;
		ligTorque[2] = 0.0;
		ligTrans[0] = 0.0;
		ligTrans[1] = 0.0;
		ligTrans[2] = 0.0;

		// loop over all involved atoms
		for(int i=0;i<thisStrand.numberOfResidues;i++){
			for(int j=0;j<thisStrand.residue[i].numberOfAtoms;j++){
				atBase = thisStrand.residue[i].atom[j].moleculeAtomNumber * 3;
				// R is the vector from the COM to the current atom
				R[0] = m.actualCoordinates[atBase] - centOfMass[0];
				R[1] = m.actualCoordinates[atBase+1] - centOfMass[1];
				R[2] = m.actualCoordinates[atBase+2] - centOfMass[2];
				// F is the current gradient for the atom of interest
				F[0] = m.gradient[atBase];
				F[1] = m.gradient[atBase+1];
				F[2] = m.gradient[atBase+2];
				temp = crossProduct(R,F);
				ligTorque[0] += temp[0];
				ligTorque[1] += temp[1];
				ligTorque[2] += temp[2];
				ligTrans[0] += F[0];
				ligTrans[1] += F[1];
				ligTrans[2] += F[2];
			}
		}

	}

	// Applies the specified torque and rigid body translation to the
	//  atoms in the ligand
	// The total translation can not be more than lligMaxTrans
	// The torque is applied with a magnitude of lligRotStep
	private void applyLigTorqueTrans(double ligTorque[], double lligRotStep,
		double ligTrans[], double lligTransStep, double lligMaxTrans){
	
		// normalize the ligand translation
		// ligTrans will now have magnitude lligTransStep if the current magnitude is greater than lligTransStep
		// we change sign because the gradient points uphill
		double ligTransMag = getMagnitude(ligTrans);
		double scale = 1.0;
		if (ligTransMag>lligTransStep)
			scale = ligTransMag/lligTransStep;
		if (scale != 0.0) {
			ligTrans[0] /= -scale;
			ligTrans[1] /= -scale;
			ligTrans[2] /= -scale;
		}
		
		// determine the new COM if we took this step
		double tempCOM[] = new double[3];
		tempCOM[0] = ligCurCOM[0] + ligTrans[0];
		tempCOM[1] = ligCurCOM[1] + ligTrans[1];
		tempCOM[2] = ligCurCOM[2] + ligTrans[2];
		
		// compute how large of a step this would be from the
		//  start point
		double totalMovement [] = new double[3];
		totalMovement[0] = tempCOM[0] - ligStartCOM[0];
		totalMovement[1] = tempCOM[1] - ligStartCOM[1];
		totalMovement[2] = tempCOM[2] - ligStartCOM[2];
		scale = getMagnitude(totalMovement);
		
		// if the step would take us too far away then
		//  scale it back
		if (scale > lligMaxTrans){
			scale = scale / lligMaxTrans;
			totalMovement[0] /= scale;
			totalMovement[1] /= scale;
			totalMovement[2] /= scale;
		}
		
		// compute the translation to get us to the new COM
		float theTranslation[] = new float[3];
		theTranslation[0] = (float)(ligStartCOM[0] + totalMovement[0] - ligCurCOM[0]);
		theTranslation[1] = (float)(ligStartCOM[1] + totalMovement[1] - ligCurCOM[1]);
		theTranslation[2] = (float)(ligStartCOM[2] + totalMovement[2] - ligCurCOM[2]);

		// update the current COM
		ligCurCOM[0] = ligStartCOM[0]+totalMovement[0];
		ligCurCOM[1] = ligStartCOM[1]+totalMovement[1];
		ligCurCOM[2] = ligStartCOM[2]+totalMovement[2];
		
		// Apply torque
		// Since our step size is fixed we just need to know the
		//  vector to rotate around
		// we change sign because the gradient points uphill
		double mag = getMagnitude(ligTorque);
		if (mag != 0.0) {
			ligTorque[0] /= -mag;
			ligTorque[1] /= -mag;
			ligTorque[2] /= -mag;
			// The last parameter says not to update the atom coordintes,
			//  only update the actualCoords
			if (Math.abs(lligRotStep)>0.0001)   // this should be in
				m.rotateStrandAroundCOM(ligStrNum,(float)ligTorque[0],(float)ligTorque[1],(float)ligTorque[2],(float)lligRotStep,false);
		}
		// Apply translation, don't update atom coordinates
		// The last parameter says not to update the atom coordintes,
		//  only update the actualCoords
		m.translateStrand(ligStrNum,theTranslation[0],theTranslation[1],theTranslation[2],false);
	}
	
	// Returns the cross product: a x b
	public double[] crossProduct(double a[], double b[]){

		double f[] = new double[3];
		f[0] = a[1]*b[2] - a[2]*b[1];
		f[1] = a[2]*b[0] - a[0]*b[2];
		f[2] = a[0]*b[1] - a[1]*b[0];
		return(f);
	}
	
	//Checks if there is a steric clash between any atoms, for all residues in the molecule
	private boolean isAllowedSteric(){
		
		m.backupAtomCoord();//store the original atoms coordinates
		m.updateAtomCoord();//update the coordinates for the current atoms
		
		for (int r1=0; r1<m.numberOfResidues; r1++){
			Residue res1 = m.residue[r1];
			for(int a1=0;a1<res1.numberOfAtoms;a1++) {
				if ( hVDW || (!(res1.atom[a1].elementType.equalsIgnoreCase("H")))) {					
					for (int r2=r1+1; r2<m.numberOfResidues; r2++){
						Residue res2 = m.residue[r2];	
						for(int a2=0;a2<res2.numberOfAtoms;a2++) {
							if ( hVDW || (!(res2.atom[a2].elementType.equalsIgnoreCase("H")))) {
								Atom tmpAtm = res2.atom[a2];								
								if ((res1.atom[a1].distance(tmpAtm) < ((tmpAtm.radius + res1.atom[a1].radius)/100.0) - 1.2)){
									if (!(res1.atom[a1].bondedTo(tmpAtm.moleculeAtomNumber))) {
										m.restoreAtomCoord();//restore the original atoms coordinates
										return false;
									}
								}
							}
						}
					}
				}	
			}
		}
	
		// If you got here then everything passed
		m.restoreAtomCoord();//restore the original atoms coordinates
		return true;
	}
}
